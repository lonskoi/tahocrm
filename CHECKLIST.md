# Чеклист проверки приложения

> Актуально: текущий `lib/logger.ts` пишет логи в stdout/stderr (`console.log/warn/error`).
> Файлы `logs/application-*.log` и `logs/error-*.log` используются только если отдельно подключен файловый транспорт.

## Автоматические проверки

### Перед каждым коммитом (pre-commit)

✅ ESLint с автоисправлением
✅ Prettier для форматирования
✅ Проверка типов TypeScript

### Полная проверка

```bash
npm run check-all
```

Выполняет:

1. ✅ Проверку типов TypeScript
2. ✅ Линтинг кода
3. ✅ Запуск тестов
4. ✅ Проверку сборки

## Preflight перед началом работ (обязательно)

- [ ] Поднять всё необходимое для запуска приложения (Postgres/Docker, `.env`, dev-сервер)
- [ ] Проверить базовую готовность: `GET /api/health` должен возвращать `200`
- [ ] Проверить базовый вход: `/crm/tenant-1/login`
- [ ] Свериться с актуальными правилами в `CHECKLIST.md` и `README.md`
- [ ] Свериться с текущим контекстом и последними записями в `AGENT_RUN_LOG.md`
- [ ] Только после preflight-проверки приступать к правкам кода

## Язык коммуникации (обязательно)

- [ ] Вся коммуникация с пользователем ведется на русском языке
- [ ] Ответы, пояснения по изменениям и статусы выполнения формулируются на русском языке
- [ ] Оригинальные англоязычные фрагменты допускаются только для кода, логов и точных текстов ошибок

## Автономное выполнение (обязательно)

- [ ] Задача выполняется полным циклом без остановки на промежуточном этапе: preflight -> реализация -> проверка -> отчет
- [ ] Для production-деплоя выполнен безопасный цикл: preflight -> deploy -> smoke -> rollback-plan
- [ ] Результаты каждого этапа зафиксированы в `AGENT_RUN_LOG.md`
- [ ] При выявлении критичного риска выполнена остановка и явное согласование дальнейших действий

## Ручные проверки

### После изменений в API

- [ ] Проверить логи приложения (stdout/stderr, при наличии транспортов также `logs/application-*.log`)
- [ ] Проверить обработку ошибок
- [ ] Убедиться что все действия логируются

### После изменений в базе данных

- [ ] Запустить миграции: `npm run db:migrate`
- [ ] Проверить схему: `npm run db:studio`
- [ ] Убедиться что индексы созданы

### После добавления нового функционала

- [ ] Написать тесты
- [ ] Добавить логирование
- [ ] Обновить документацию
- [ ] Проверить типы

## Мониторинг логов

### Просмотр логов в реальном времени

```bash
# Локально (stdout/stderr через npm run dev)
npm run dev

# Docker (если приложение в контейнере)
docker compose logs -f app

# Все логи из файлов (если включен файловый транспорт)
tail -f logs/application-*.log

# Только ошибки из файлов (если включен файловый транспорт)
tail -f logs/error-*.log
```

### Поиск проблем

```bash
# Ошибки за сегодня
grep "$(date +%Y-%m-%d)" logs/error-*.log

# Поиск по пользователю
grep "userId.*user-1" logs/application-*.log

# Поиск по действию
grep "CREATE_TASK" logs/application-*.log
```

## Структура логов

Каждый лог содержит:

- `timestamp` - время события
- `level` - уровень (info, warn, error, debug)
- `message` - описание события
- `context` - контекст (userId, tenantId, entityId и т.д.)
- `duration` - длительность операции (для API)
- `error` - детали ошибки (если есть)

## Примеры хороших логов

### ✅ Хорошо

```typescript
logger.info('GET /api/tasks - Success', {
  tenantId: 'tenant-1',
  userId: 'user-1',
  taskCount: 5,
  duration: '45ms',
  timestamp: new Date().toISOString(),
})
```

### ❌ Плохо

```typescript
console.log('Tasks loaded') // Нет контекста, нет структуры
```

## Проверка после деплоя

1. Проверить что логи создаются
2. Проверить что ошибки логируются
3. Проверить производительность (duration в логах)
4. Проверить что все API routes работают
5. Проверить что тесты проходят

## Server parity (обязательно перед merge/deploy)

- [ ] Проверить, что изменения не ослабляют production-guards (`NODE_ENV`, auth, tenant-изоляция)
- [ ] Запустить минимум `npm run type-check` и релевантные тесты для измененной области
- [ ] Выполнить smoke-сценарий как в production (логин, переходы, ключевые API)
- [ ] Зафиксировать результат проверки в `AGENT_RUN_LOG.md`

## Local parity (обязательно перед merge/deploy)

- [ ] После server-side изменений запустить локальный сценарий (`npm run dev` или `npm run start:verified` на Windows)
- [ ] Проверить локальный smoke: `/api/health` и `/crm/tenant-1/login`
- [ ] Убедиться, что изменения в Docker/env/migrations/auth не ломают локальный вход и базовые API
- [ ] Зафиксировать результат локальной parity-проверки в `AGENT_RUN_LOG.md`

## Root-cause first (обязательно)

- [ ] В первую очередь устранять первопричину проблемы, а не симптомы
- [ ] Временные обходы (fallback/заплатки) допускаются только как краткосрочная мера с явным планом удаления
- [ ] Перед закрытием задачи убедиться, что временные обходы удалены или имеют зафиксированный removal plan
- [ ] Зафиксировать в `AGENT_RUN_LOG.md`, почему это root-cause fix, а не workaround

## Timestamp coverage (обязательно)

- [ ] Для сущностей CRM/admin добавлены и синхронизированы `businessCreatedAt/businessUpdatedAt`
- [ ] В таблицах/списках отображаются дата и время (приоритет `business*` -> fallback `createdAt/updatedAt`)
- [ ] В create/edit формах доступны редактируемые `businessCreatedAt/businessUpdatedAt`
- [ ] `createdAt/updatedAt` остаются системными audit-only полями (без ручного редактирования)
- [ ] Для документов/генерации используется бизнес-дата с fallback на системные поля
